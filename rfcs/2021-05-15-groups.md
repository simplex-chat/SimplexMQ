# SMP agent groups

## Problems

- device/user profile synchronisation
- group communication

Both use cases can be facilitated by message broadcast between a group of SMP agents.

## Solution: symmetric groups as part of SMP agent protocol

The proposed approach does not scale to large groups, as each agent has to broadcast the messages of their clients to all other agents in the group. While for large group it is more effective to have a server managing the list of group members, it introduces the challenges with key distribution, privacy etc.

This proposal contains the set of additional SMP agent commands and message envelopes to provide a low level abstraction for group communication.

The groups are symmetric, all agents who are members of the group have equal rights and can add and remove members and leave group.

All the information about the groups is stored only in the agents.

As these groups are intended to be small and consist of users who sufficiently trust each other, and for simplicity, the initial protocol version assumes that any group member can add and remove users, and these actions will be replicated by other agents without asking user approval up to a certain number of users, after which an approval can be asked.

## Group message integrity

Two approaches are possible:

1. Each agent on a regular interval sends to all agents the sender IDs and the digests of the last messages from all agents they communicate with.
To avoid `(n-1)*n` messages for each group integrity verification, IDs and digests from all senders can be compacted in one messages:

```
broadcast: %s"G_CHECK" SP memId1 ":" msgId1 ":" hash1 ":" status1 "," memId2 ":" msgId2 ":" hash2 ":" status2
```

A side question is that we currently do not support large agent messages; possibly we should support messages larger than SMP block size to simplify this and other scenarios, similarly to how websockets protocol does it. There might still be a limit to how large the full message can be. That probably requires re-thinking of how messages are managed and separation of message reception from the servers and message delivery to the clients, but this might be required anyway for when we start running the agent in the background.

The above approach requires a way to identify all members by all members to all members, but such tripartite IDs are generated when adding the new members to the group (e.g. `gidABM` in the sequence diagram).

There may be two situations to consider:

1) The recipient of this verification message can have the same message as the last one or they can have more messages received - both such scenarios are ok and do not necessarily receive a problem, as they just might be slightly ahead in receiving the messages. They would make the last matching message as ok, and the later would remain unknown - it does not indicate the lack of integrity of the group, although if the next integrity check without the same messages does (this needs to be clarified).
2) The recipient of this verification message can have fewer messages received. This situation can be resolved in several ways:
- try to retrieve all messages from the queue that is behind. It might work, but it may be that the sender is simply trying to send messages because the network is down.
- wait until the next integrity check and only report integrity violation if during the next integrity check they still cannot reconcile the previous integrity check. This is probably an acceptable compromise.

2. Each agent sends message receipts to sending agents - message receipts would contain a signature of the message hashes. In the agent uses the same verification key for each member of the group, as considered below, these receipts can be re-broadcasted to other agents (again, grouping them in one message to avoid `(n-1)*n` messages) as a proof that the messages were delivered.

Comparing with the first approach, there are pros and cons:
- pros:
  - the sender would only send such integrity check messages when they have send a message to all parties, thus avoiding the situation when some messages might have been not yet sent (or failed to send and they are retrying).
- cons:
  - integrity check message mush contain a signature per member, so it would be substantially larger.
  - agents must use the same verification key for all members in the group, complicating the group and connections management.

Overall the first approach seems better. It shows who received which messages and the only case where the lack of integrity would be reported if the same message is different or some messages are skipped to some recipients (i.e. they broadcast integrity violation for some of the senders).

## Agent commands and messages syntax

- command `gId? GNEW gInfo` - create group (response is `gId OK`)
- command `gId GADD role cAlias` - add existing connection to a group
- message `cAlias GINV invId gMeta gInfo` - invitation to join the group
- command `gId? GJOIN invId` - accept invitation (response is `gId OK`)
- message `gId GCON cAlias` - 2 connections created with some group member (both for group and direct messages)
- message `gId GJOINED` - connection created with all group members
- command `gId GSEND msg` - send message to group
- message `gId GSENT msgId` - notification that the message is sent and its internal ID, same as SENT
- message `gId GMSG cAlias msgdata` - received group message from cAlias, msgdata is the same set of parameters as in `MSG`
- TODO: `GACK`, `GRCVD`
- command `gId GLEAVE` - leave the group
- message `gId GLEFT cAlias` - connection cAlias left the group
- command `gId GREM cAlias` - remove group member (response is `gId OK`, followed by `GREMD` notification)
- message `gId GREMD cAlias` - member removed
- message `gId GOUT` - you are removed (see question below - should it be just a sequence of GLEFT?)
- message `gId GEMPTY` - all members left the group and it is now empty
- command `gId GDEL` - delete the group (response is `gId OK`)
- TODO changing member roles

## Agent message envelopes

- `G_INV role intInv gMeta gInfo` - invitation to join the group
- `GM_ADD lvl mid` - shared member ID and connection level (see sequence diagram)
- `GM_INV mid1 mid2 inv intInv` - queueInfos to be passed to an existing member (previously referred to in G_MEM)
- `GM_NEW lvl mid1 mid2 inv intInv` - queueInfos from the new member to the existing member (sent by the agent that invited the new member)
- `G_CON mid` - confirmation about connection to a member
- `GM_ALL` - confirmation that there are no more members (so no more GM_ADD will be sent in this group, the number of GM_ADD can be more than what was sent in gMeta because some new members could have been added between G_INV and AM_ALL that needed to be sent. Managing race conditions needs clarification).
- `G_MSG msgdata` - group message, msgdata is the same as in A_MSG
- `G_OUT` - you are removed from the group
- `G_REM mid` - remove member mid from the group
- `G_REMD mid` - confirmation that member is removed
- `G_DEL` - group is deleted
- TODO updates to member roles

## Questions

1. Message verification keys. Agents use separate server and encryption key for each connection, but there can be a value of having the same message verification key used for all members in the group. E.g., a member can validate to other group members that the message was delivered to all group members by sending signed message receipts they receive from the agent. This would mean that for each message `n*(n-1)` messages will be send, although signed receipts can be grouped to reduce this number. It can be done periodically, rather than on each message, as described [here](https://signal.org/blog/private-groups/).

2. Is there a value having a separate set of commands for groups or should we just use the same commands to perform different actions in the group context: SEND, SENT, etc.?

3. There may be a value in designating the role of the group administrators and owners, and make that other members would only recognise the commands to add and delete members and remove the groups from the administrator. It still means that any member can pretend to be an administrator to the new members, they can broadcast to them the messages from the original group, but they won't be able to connect them to all pre-existing members. This is relatively simple protocol extension, can be included in early iterations.

4. There may be value of requiring some level of consensus for certain destructive action - e.g. two of three owners should agree to delete the group before this instruction is executed by other members. This is probably best not to include in the protocol in early versions, as it is complex.

5. How to signal that you are removed from the group. Should you know who removed you? Should you just receive notifications that members left the group one by one and then GEMPTY?

The [sequence digram for group operations](https://mermaid-js.github.io/mermaid-live-editor/#/view/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gIHBhcnRpY2lwYW50IE0gYXMgRXhpc3Rpbmc8YnI-bWVtYmVyIChNKVxuICBwYXJ0aWNpcGFudCBNQSBhcyBFeGlzdGluZzxicj5tZW1iZXI8YnI-YWdlbnQgKE1BKVxuICBwYXJ0aWNpcGFudCBBIGFzIEFsaWNlIChBKVxuICBwYXJ0aWNpcGFudCBBQSBhcyBBbGljZSdzPGJyPmFnZW50IChBQSlcbiAgcGFydGljaXBhbnQgQkEgYXMgQm9iJ3M8YnI-YWdlbnQgKEJBKVxuICBwYXJ0aWNpcGFudCBCIGFzIEJvYiAoQilcblxuICBub3RlIG92ZXIgQSwgQUE6IDEuIGNyZWF0ZSBuZXcgZ3JvdXAgKG5vIG1lbWJlcnMpXG4gIEEgLT4-IEFBOiBnaWRBPyBHTkVXIGdJbmZvPGJyPihnaWRBIC0gY29ubiBhbGlhcyBvZiB0aGlzIGdyb3VwIGZvciBBLDxicj5jYW4gYmUgZ2VuZXJhdGVkIGJ5IHRoZSBhZ2VudC48YnI-RG9lcyBpdCBzaGFyZSBuYW1lc3BhY2Ugd2l0aCBjb25uZWN0aW9ucz8pXG4gIEFBIC0-PiBBOiBnaWRBIE9LPGJyPihvciBHT0s_KVxuXG4gIG5vdGUgb3ZlciBBLCBCQTogMi4gYWRkIEJvYiB0byBncm91cFxuICBBIC0-PiBBQTogZ2lkQSBHQUREIGlkQUI8YnI-KGlkQUIgLSBjb25uIGFsaWFzIEEgaGFzIGZvciBCKVxuICBcbiAgbm90ZSBvdmVyIEFBOiBpbml0aWF0ZSBpbnRlcm5hbCBjb25uZWN0aW9uIGdpZEFCIGZvciBCIGluIGdyb3VwXG5cbiAgQUEgLT4-IEJBOiB2aWEgaWRBQjogR19JTlYgZ2lkQUJpbnYgZ01ldGEgZ0luZm88YnI-KGdNZXRhIGNvbnRhaW5zIG51bWJlciBvZiBtZW1iZXJzIC0gVEJDIHdoYXQgZWxzZTxicj5zaG91bGQgbm90IGNvbnRhaW4gZGF0ZSBvZiBjcmVhdGlvbiBvciB3aG8gY3JlYXRlZCBpdClcbiAgQkEgLT4-IEI6IGlkQkEgR0lOViBpbnZJRCBnTWV0YSBnSW5mb1xuICBCIC0-PiBCQTogZ2lkQj8gR0pPSU4gaW52SUQ8YnI-KGNvdWxkIGJlIGFsc28gR1JFSkVDVCBpbnZJRD8pXG4gIEJBIC0-PiBCOiBnaWRCIE9LXG5cbiAgQkEgLT4-IEFBOiBlc3RhYmxpc2ggaW50ZXJuYWwgY29ubmVjdGlvbiBnaWRCQSAodXNpbmcgZ2lkQUJpbnYpIGZvciBBIGluIGdyb3VwPGJyPihpbnRlcm1hbCBtZWFucyB0aGF0IGl0IGlzIG5vdCB2aXNpYmxlIHRvIHRoZSBjbGllbnRzLiBTZXBhcmF0ZSBuYW1lc3BhY2U_KVxuIFxuICBBQSAtPiBBOiBnaWRBIEdDT04gaWRBQlxuXG4gIG5vdGUgb3ZlciBNLCBCOiBiZWxvdyBzdGVwcyBoYXBwZW4gZm9yIGVhY2ggZXhpc3RpbmcgbWVtYmVyIE1cblxuICBBQSAtPj4gQkE6IHZpYSBnaWRCQTogR01fQUREIGx2bEFNIG1pZEFCTXxfPGJyPihtaWRBQk0gLSBob3cgQSBpZGVudGlmaWVzIG1lbWJlciBNIHRvIEIsPGJyPmx2bEFNIC0gY29ubmVjdGlvbiBsZXZlbCwgMCAtIGRpcmVjdCwgMSAtIHZpYSBzbWJkeSBldGMuKVxuICBcbiAgbm90ZSBvdmVyIEJBOiBpbml0aWF0ZSBjb25uZWN0aW9uIGlkQk0gZm9yIGRpcmVjdCBtZXNzYWdlcyBhbmQ8YnI-IGludGVybmFsIGdpZEJNIGZvciBncm91cCBtZXNzYWdlcyBiZXR3ZWVuIEIgYW5kIE1cbiAgXG4gIEJBIC0-PiBBQTogdmlhIGdpZEJBOiBHTV9JTlYgbWlkQUJNfEJBTSBpZEJNaW52L2dpZEJNaW52PGJyPihtaWRCQU0gLSBob3cgQiBpZGVudGlmaWVzIG1lbWJlciBNIHRvIEE8YnI-aWRCTWludi9naWRCTWludiAtIGludml0YXRpb25zIHRvIGNvbm5lY3QgZm9yIG1lbWJlciBNKVxuXG4gIEFBIC0-PiBNQTogdmlhIGdpZEFNOiBHTV9ORVcgbHZsQUIgbWlkQU1CIGlkQk1pbnYvZ2lkQk1pbnY8YnI-KG1pZEFNQiAtIGhvdyBBIGlkZW50aWZpZXMgQiB0byBtZW1iZXIgTSw8YnI-bHZsQUIgLSBjb25uZWN0aW9uIGxldmVsLCAwIC0gZGlyZWN0IGV0Yy4pXG5cbiAgTUEgLT4-IEJBOiBlc3RhYmxpc2ggY29ubmVjdGlvbiB3aXRoIGlkQk0gLT4gaWRNQlxuICBNQSAtPj4gQkE6IGVzdGFibGlzaCBpbnRlcm5hbCBjb25uZWN0aW9uIHdpdGggZ2lkQk0gLT4gZ2lkTUJcblxuICBNQSAtPj4gQUE6IHZpYSBnaWRNQTogR19DT04gbWlkQU1CfE1BQiAob3IgR19BRERfRVJSKVxuICBNQSAtPj4gTTogZ2lkTSBHQ09OIGlkTUJcblxuICBCQSAtPj4gQUE6IHZpYSBnaWRCQTogR19DT04gbWlkQUJNfEJBTSAob3IgR19BRERfRVJSKVxuICBCQSAtPj4gQjogZ2lkQiBHQ09OIGlkQk1cblxuICBub3RlIG92ZXIgQSwgQkE6IG9uY2UgYWxsIG1lbWJlcnMgd2VyZSBzZW50IHRvIEJcbiAgQUEgLT4-IEJBOiB2aWEgZ2lkQUI6IEdfQUxMXG4gIEJBIC0-PiBCOiBnaWRCIEdKT0lORURcblxuICBub3RlIG92ZXIgQSwgQUE6IG9uY2UgYWxsIG1lbWJlcnMgcmVwb3J0ZWQgY29ubmVjdGlvblxuICBBQSAtPj4gQTogZ2lkQSBHQUxMIGlkQUJcbiAgXG4gIG5vdGUgb3ZlciBNLCBCOiAzLiBCIHNlbmRzIG1lc3NhZ2UgdG8gdGhlIGdyb3VwXG5cbiAgQiAtPj4gQkE6IGdpZEIgR1NFTkQgbXNnXG4gIEJBIC0-PiBBQTogdmlhIGdpZEJBOiBHX01TRyBtc2c8YnI-bXNnIGhhcyB0aGUgc2FtZSBmb3JtYXQgYXMgQV9NU0dcbiAgQUEgLT4-IEE6IGdpZEEgR01TRyBpZEFCIG1zZ1xuICBCQSAtPj4gTUE6IHZpYSBnaWRCTTogR19NU0cgbXNnXG4gIE1BIC0-PiBNOiBnaWRNIEdNU0cgaWRNQiBtc2dcbiAgQkEgLT4-IEI6IGdpZEIgR1NFTlQgbXNnSURcblxuICBub3RlIG92ZXIgTSwgQjogNGEuIEEgbGVhdmVzIGdyb3VwXG5cbiAgQSAtPj4gQUE6IGdpZEEgR0xFQVZFXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBHX0xFRlRcbiAgbm90ZSBvdmVyIEFBOiByZW1vdmUgZ2lkQUJcbiAgQkEgLT4-IEI6IGdpZEI6IEdMRUZUIGlkQkFcbiAgbm90ZSBvdmVyIEJBOiByZW1vdmUgZ2lkQkFcbiAgQUEgLT4-IE1BOiB2aWEgZ2lkQU06IEdfTEVGVFxuICBub3RlIG92ZXIgQUE6IHJlbW92ZSBnaWRBTVxuICBNQSAtPj4gTTogZ2lkTTogR0xFRlQgaWRNQVxuICBub3RlIG92ZXIgTUE6IHJlbW92ZSBnaWRNQVxuXG4gIG5vdGUgb3ZlciBNLCBCOiA0Yi4gQSByZW1vdmVzIEIgZnJvbSBncm91cFxuXG4gIEEgLT4-IEFBOiBnaWRBIEdSRU0gaWRBQlxuICBBQSAtPj4gQkE6IHZpYSBnaWRBQjogR19PVVRcbiAgbm90ZSBvdmVyIEFBOiByZW1vdmUgZ2lkQUJcbiAgQUEgLT4-IEE6IGdpZEEgT0tcbiAgQkEgLT4-IEI6IGdpZEI6IEdPVVQgaWRCQVxuICBub3RlIG92ZXIgQkE6IHJlbW92ZSBnaWRCQSBhbmQgYWxsIG90aGVyIGNvbm5lY3Rpb25zXG5cbiAgbm90ZSBvdmVyIE0sIEI6IGJlbG93IHN0ZXBzIGhhcHBlbiBmb3IgZWFjaCBleGlzdGluZyBtZW1iZXIgTVxuXG4gIEFBIC0-PiBNQTogdmlhIGdpZEFNOiBHX1JFTSBtaWRBTUJ8TUFCXG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGdpZE1CXG4gIE1BIC0-PiBBQTogdmlhIGdpZE1BOiBHX1JFTUQgbWlkQU1CfE1BQlxuICBNQSAtPj4gTTogZ2lkTTogR1JFTUQgaWRNQlxuXG4gIG5vdGUgb3ZlciBCLCBCQTogb25jZSBhbGwgbWVtYmVycyByZW1vdmVkIEIgKG9yIGFsbCBsZWZ0KVxuXG4gIEFBIC0-PiBBOiBnaWRBOiBHUkVNRCBpZEFCXG5cbiAgbm90ZSBvdmVyIE0sIEI6IDRjLiBBIGRlbGV0ZXMgZ3JvdXBcbiAgQSAtPj4gQUE6IGdpZEEgR0RFTFxuICBBQSAtPj4gQkE6IHZpYSBnaWRBQjogR19ERUxcbiAgbm90ZSBvdmVyIEJBOiByZW1vdmUgYWxsIGdyb3VwIGNvbm5lY3Rpb25zIGFuZCBtZXNzYWdlc1xuICBCQSAtPj4gQjogZ2lkQjogR0RFTEVURUQgaWRCQVxuICBBQSAtPj4gTUE6IHZpYSBnaWRBTTogR19ERUxcbiAgTUEgLT4-IE06IGdpZE06IEdERUxFVEVEIGlkTUFcbiAgbm90ZSBvdmVyIE1BOiByZW1vdmUgYWxsIGdyb3VwIGNvbm5lY3Rpb25zIGFuZCBtZXNzYWdlc1xuICBBQSAtPj4gQTogZ2lkQSBPS1xuIiwibWVybWFpZCI6e30sInVwZGF0ZUVkaXRvciI6ZmFsc2V9), the source is in ./groups/groups.mmd.

## Relevant external documents

[Signal group protocol](https://signal.org/blog/private-groups/)

[mpOTR](https://cypherpunks.ca/~iang/pubs/mpotr.pdf)

[Threema whitepaper](https://threema.ch/press-files/cryptography_whitepaper.pdf)
